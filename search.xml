<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库事务管理详解</title>
      <link href="/posts/shu-ju-ku-shi-wu-guan-li-xiang-jie/"/>
      <url>/posts/shu-ju-ku-shi-wu-guan-li-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><ul><li>事务（transaction）：是一组 SQL语句，是保证逻辑数据完整性和可恢复性的重要利器</li><li>回退（rollback）：撤销指定 SQL 语句</li><li>提交（commit）：将未存储的 SQL 语句写入数据库表</li><li>保留点（savepoint）：事务处理中临时占位符（placeholder），可以对其回退（不需要回退整个事务）</li></ul><h2 id="事务状态">事务状态</h2><p><img src="1.jpeg" alt="状态转换图" /></p><ul><li>活跃状态：任何正在执行的事务都在此，操作进入部分提交状态</li><li>部分提交状态：执行上次操作后进入，更改存储在内存中</li><li>提交状态：所有操作执行完后进入此状态，此时不能回滚</li><li>失败状态：发生错误，事务进入终止状态</li><li>终止状态：进行回滚</li></ul><h2 id="事务的特征acid">事务的特征（ACID）</h2><ol type="1"><li>原子性（Atomiocity）：事务的操作要么全都执行要么都不执行</li><li>一致性（Consistency）：数据库从一个一致状态转变为另一个一致状态</li><li>隔离性（Isolation）：并发的事务间相不干扰，相互隔离</li><li>持久性（Durability）：事务一旦提交，影响是持久的</li></ol><h2 id="事务间相互影响">事务间相互影响</h2><p>事务A和事务B操作同一个银行账号，初始余额为0。</p><ul><li>脏读：事务B存入100元，此时事务A查余额，为100，但事务B发生了错误，回滚了，余额又重新变成了0，出现了不一致的情况，此时便说事务A读到了脏数据。</li><li>不可重复读：事务A查余额，为0，事务B存入100元并成功提交，此时事务A再查余额，变成了100，同样的查询得到不同的结果，这就是不可重复读。</li><li>幻读：与不可重复读有点像，但幻读强调的是查询结果为多条数据的场景。A查余额明细，有20条，B存入100元，使得余额明细多了一条，然后提交成功，此时A再查余额明细，得到了21条，这就是幻读。</li><li>丢失更新：事务A和B同时开始，A存入100元，B存入50元，A先于B提交成功，此时余额为100，但当B提交成功后，余额变成了50，A对余额的更新就不见了，这就是丢失更新。</li></ul><h2 id="事务的隔离级别">事务的隔离级别</h2><table><colgroup><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /></colgroup><thead><tr class="header"><th><strong>隔离级别</strong></th><th><strong>读数据一致性</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr class="odd"><td><strong>未提交(RU)</strong></td><td>只能保证不读取物理上的损坏</td><td>√</td><td>√</td><td>√</td></tr><tr class="even"><td><strong>已提交(RC)</strong></td><td>语句级</td><td>×</td><td>√</td><td>√</td></tr><tr class="odd"><td><strong>可重复读(RR)</strong></td><td>事务级</td><td>×</td><td>×</td><td>√</td></tr><tr class="even"><td><strong>串行化(SR)</strong></td><td>最高级别，事务级</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><hr /><p>事务A与事务B并发访问数据库：</p><ol type="1"><li>读未提交<br />A可以看到B正在修改而未commit的数据，A读的是实时数据，所以会出现脏读现象。</li><li>读已提交<br />A只能看到B提交后的数据，但是B若多次提交，A读的数据不相同，所以出现幻读现象。</li><li>可重复读（MySQL 默认隔离级别）<br />A只能读到A事务开启前的数据，所以B无论提交多少次，A看到的数据都是不变的，故可以重复读。</li><li>序列化<br />A与B不能并发，只能顺序执行</li></ol><h2 id="代码">代码</h2><h3 id="正常流程">正常流程</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> orderitems <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20010</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> orders <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20010</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token comment"># 或</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：当 <code>COMMIT</code> 或 <code>ROLLBACK</code>后，事务会自动关闭</p></blockquote><h3 id="保留点">保留点</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SAVEPOINT</span> delete1<span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> delete1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="自动提交">自动提交</h3><p><img src="2.png" alt="自动提交" /></p><p><code>SET autocommit=0;</code> 来取消自动提交，所谓自动提交就是不使用<code>COMMIT</code> 就直接将数据更改到数据库，而不通过内存</p><h2 id="哪些语句可以回退">哪些语句可以回退？</h2><p>DML（Data Manipulation Language） 语句： INSERT, UPDATE, DELETE</p><blockquote><p>注：回退 SELECT 没有意义，而 CREATE, DROP, TRUNCATE 属于 DDL都不能回退</p></blockquote><h2 id="如何实现事务的-acid-特性">如何实现事务的 ACID 特性</h2><ul><li>归档日志 bin log</li><li>回滚日志 undo log</li><li>重做日志 redo log</li></ul><hr /><ul><li>原子性：通过 undo log 记录 sql 操作，当发生回滚，逆序逆操作</li><li>持久性：bin log &amp; redo log</li><li>一致性：bin log</li><li>隔离性：事务的隔离级别，通过锁机制及 MVCC 来实现</li></ul><h2 id="参考">参考</h2><p><ahref="https://www.cnblogs.com/kismetv/p/10331633.html">深入学习MySQL事务：ACID特性的实现原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库存储引擎对比</title>
      <link href="/posts/shu-ju-ku-cun-chu-yin-qing-dui-bi/"/>
      <url>/posts/shu-ju-ku-cun-chu-yin-qing-dui-bi/</url>
      
        <content type="html"><![CDATA[<h2 id="存储引擎是什么">存储引擎是什么？</h2><p>存储引擎是数据库的核心</p><blockquote><p><strong>百度百科</strong><br />MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p></blockquote><h2 id="存储引擎有哪些">存储引擎有哪些</h2><p>使用 <code>SHOW ENGINES;</code> 查看</p><p><img src="1.png" alt="存储引擎一览" /></p><table style="width:100%;"><colgroup><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>存储引擎</strong></th><th style="text-align: center;"><strong>MyISAM</strong></th><th style="text-align: center;"><strong>InnoDB</strong></th><th style="text-align: center;"><strong>BDB</strong></th><th style="text-align: center;"><strong>Memory</strong></th><th style="text-align: center;"><strong>Archive</strong></th><th style="text-align: center;"><strong>NDB</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>存储限制</strong></td><td style="text-align: center;">无</td><td style="text-align: center;">64TB</td><td style="text-align: center;">无</td><td style="text-align: center;">有</td><td style="text-align: center;">无</td><td style="text-align: center;">有</td></tr><tr class="even"><td style="text-align: center;"><strong>事务</strong></td><td style="text-align: center;"></td><td style="text-align: center;">支持</td><td style="text-align: center;">支持</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><strong>锁级别</strong></td><td style="text-align: center;">表锁</td><td style="text-align: center;">行锁</td><td style="text-align: center;">page</td><td style="text-align: center;">表</td><td style="text-align: center;">行</td><td style="text-align: center;">行</td></tr><tr class="even"><td style="text-align: center;"><strong>MVCC（并发控制）</strong></td><td style="text-align: center;"></td><td style="text-align: center;">支持</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">支持</td><td style="text-align: center;">支持</td></tr><tr class="odd"><td style="text-align: center;"><strong>全文索引</strong></td><td style="text-align: center;">支持</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><strong>集群索引</strong></td><td style="text-align: center;"></td><td style="text-align: center;">支持</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><strong>数据缓存和索引缓存</strong></td><td style="text-align: center;"></td><td style="text-align: center;">支持</td><td style="text-align: center;"></td><td style="text-align: center;">支持</td><td style="text-align: center;"></td><td style="text-align: center;">支持</td></tr><tr class="even"><td style="text-align: center;"><strong>数据压缩</strong></td><td style="text-align: center;">支持</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">支持</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><strong>批量插入速度</strong></td><td style="text-align: center;">高</td><td style="text-align: center;">低</td><td style="text-align: center;">高</td><td style="text-align: center;">高</td><td style="text-align: center;">很高</td><td style="text-align: center;">高</td></tr><tr class="even"><td style="text-align: center;"><strong>集群数据库支持</strong></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">支持</td></tr><tr class="odd"><td style="text-align: center;"><strong>外键支持</strong></td><td style="text-align: center;"></td><td style="text-align: center;">支持</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><strong>适用场景</strong></td><tdstyle="text-align: center;">不需要事务的操作；插入、更新少，读取频繁；频繁的统计计算。</td><tdstyle="text-align: center;">需要事务的操作；更新数据需要使用行级锁；大数据量读写；大型互联网应用。</td><td style="text-align: center;">类似 InnoDB</td><tdstyle="text-align: center;">数据量不大，需要被频繁的访问，而且数据丢失不会对业务产生比较严重的影响。</td><tdstyle="text-align: center;">存储引擎基本上用于数据归档，作为日志表</td><td style="text-align: center;">集群</td></tr><tr class="odd"><td style="text-align: center;"><strong>特点</strong></td><td style="text-align: center;"></td><td style="text-align: center;"></td><tdstyle="text-align: center;">可替代InnoDB的事务引擎，支持COMMIT、ROLLBACK和其他事务特性</td><tdstyle="text-align: center;">数据存储在内存中，重启或崩溃，数据消失，使用哈希索引</td><tdstyle="text-align: center;">只支持Insert和Select操作，支持索引，非常适合存储归档数据，目标：高速插入和压缩功能</td><tdstyle="text-align: center;">集群存储引擎，数据全部放在内存中，高可用、高性能的集群系统</td></tr></tbody></table><p><img src="2.png" alt="适用场景" /></p><blockquote><p>注：新 MySQL 的存储引擎默认是 InnoDB</p></blockquote><p>以下内容来自 <ahref="https://www.bilibili.com/video/BV1zr4y1x7o7/?spm_id_from=pageDriver&amp;vd_source=792f3008384e88bd777ae4c2be9b658b">bilibili视频笔记</a></p><p>MySQL中常用的四种存储引擎分别是：MyISAM、InnoDB、MEMORY、ARCHIVE。MySQL5.5版本后默认的存储引擎为InnoDB。</p><h3 id="innodb存储引擎">InnoDB存储引擎</h3><p>InnoDB是MySQL默认的事务型存储引擎，使用最广泛，基于聚簇索引建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</p><p>优点：支持事务和崩溃修复能力；引入了行级锁和外键约束。</p><p>缺点：占用的数据空间相对较大。</p><p>适用场景：需要事务支持，并且有较高的并发读写频率。</p><h3 id="myisam存储引擎">MyISAM存储引擎</h3><p>数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件.MYD和索引文件.MYI。</p><p>优点：访问速度快。</p><p>缺点：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</p><p>适用场景：对事务完整性没有要求；表的数据都会只读的。</p><h3 id="memory存储引擎">MEMORY存储引擎</h3><p>MEMORY引擎将数据全部放在内存中，访问速度较快，但是一旦系统奔溃的话，数据都会丢失。</p><p>MEMORY引擎默认使用哈希索引，将键的哈希值和指向数据行的指针保存在哈希索引中。</p><p>优点：访问速度较快。</p><p>缺点：</p><p>哈希索引数据不是按照索引值顺序存储，无法用于排序。不支持部分索引匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。只支持等值比较，不支持范围查询。当出现哈希冲突时，存储引擎需要遍历链表中所有的行指针，逐行进行比较，直到找到符合条件的行。</p><h3 id="archive存储引擎">ARCHIVE存储引擎</h3><p>ARCHIVE存储引擎非常适合存储大量独立的、作为历史记录的数据。ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差。</p><h2 id="参考">参考</h2><p><ahref="https://segmentfault.com/a/1190000020383024">存储引擎对比</a></p><p><a href="https://segmentfault.com/a/1190000012588602">MySQL -常见的三种存储引擎</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引详解</title>
      <link href="/posts/shu-ju-ku-suo-yin-xiang-jie/"/>
      <url>/posts/shu-ju-ku-suo-yin-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p><img src="1.png" alt="总纲" /></p><h2 id="什么是索引">什么是索引？</h2><p>正常使用 <code>select</code>需要对表中所有元素进行遍历，效率极低，而索引是对数据库中列进行有序化的数据结构，使用其可以快速访问特定信息</p><h2 id="索引优点">索引优点</h2><ul><li>通过创建<strong>唯一性索引</strong>，可以保证数据库表中每一行数据的唯一性；</li><li>可以加快数据的<strong>检索速度</strong>，这也是创建索引的主要原因；</li><li>可以加速表和表之间的连接，特别是在实现<strong>数据的参考完整性</strong>方面特别有意义；</li><li>通过使用索引，可以在查询的过程中，使用<strong>优化隐藏器</strong>，提高系统性能。</li></ul><h2 id="索引缺点">索引缺点</h2><ul><li>时间上，创建和维护索引都要耗费时间，这种时间随着数据量的增加而增加，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</li><li>空间上，索引需要占<strong>物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li></ul><h2 id="按数据结构分类">按数据结构分类</h2><p><img src="2.png" alt="存储引擎支持索引类别" /></p><blockquote><p>注：InnoDB实际上也支持Hash索引，但是InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引</p></blockquote><h3 id="btree-索引">BTREE 索引</h3><p>B 树也称 B-树，它是一颗多路平衡查找树，相较于红黑树这种平衡树，其树的高度更低，这也意味着磁盘IO 的次数更少</p><p>B+ 树是其的 plus 版本，常用于数据库索引（InnoDB 默认），具有 B树的平衡性，同时节点间通过双向链表提高了区间查询的性能</p><p>B+tree 非叶子节点只存储键值信息，数据记录都存放在叶子节点中。而B-tree的非叶子节点也存储数据。所以 B+tree单个节点的数据量更小，在相同的磁盘I/O次数下，能查询更多的节点。</p><h3 id="位图索引">位图索引</h3><p>适用于字段取值范围小的情况，如：性别，婚姻状况</p><ul><li>不使用索引<br />不使用索引时，数据库只能一行行扫描所有记录，然后判断该记录是否满足查询条件。</li><li>BTREE 索引<br />对于性别，可取值的范围只有'男','女'，并且男和女可能各站该表的50%的数据，这时添加B树索引还是需要取出一半的数据，因此完全没有必要。相反，如果某个字段的取值范围很广，几乎没有重复，比如身份证号，此时使用B树索引较为合适。事实上，当取出的行数据占用表中大部分的数据时，即使添加了B树索引，数据库如oracle、mysql也不会使用B树索引，很有可能还是一行行全部扫描。</li></ul><p>那位图索引呢，通过位向量形式表示</p><p>性别：</p><p><img src="3.png" alt="性别位图" /></p><p>其中 1 表示为男，否则为女，则位图索引生成两个向量</p><p>男向量：10100</p><p>女向量：01011</p><p>对于婚姻状况这一列，位图索引生成三个向量，已婚为11000...，未婚为00100...，离婚为00010...</p><p><img src="4.png" alt="婚姻状况" /></p><p><code>select * from &lt;table&gt; where gender="男" and marriage="未婚"</code></p><p>取出男向量 10100，未婚向量 00100 进行 AND 操作，结果为00100，第三行为结果</p><h3 id="hash-索引">hash 索引</h3><p>哈希索引通过 hash算法（直接定址法，平方取中法，折叠法，除数取余法，随机数法）将数据转换为hash 的 key，对应的 value 为数据，MySQL 中只有 Memory引擎显式的支持哈希索引，这也是Memory引擎表的默认索引结构，Memory同时也支持B-Tree索引。并且，Memory引擎支持非唯一哈希索引，当发生hash 冲突时，使用拉链法解决</p><p>InnoBD引擎有一个特殊的功能叫“自适应哈希索引”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。但这是一个完全自动的、内部的行为，用于无法控制，但用户可以选择完全关闭该动能。</p><p>在使用InnoBD引擎时，我们可以在B-Tree的基础上创建一个伪哈希索引。当然这不是真正的哈希索引，因为还是使用的B-Tree进行查找，但它使用哈希值而不是键本身进行索引查找。</p><p>例如，如果需要存储大量的URL并且需要根据URL进行查找，如果使用B-Tree来存储URL，则存储的内容就会很大，因为URL本身就很长。为此，我们可以单独指定一个哈希列并为该列创建索引，并选择一个哈希函数！每次存储、变更URL时，对该URL应用一个函数计算出一个哈希值，存入对应的哈希列中。</p><p>在查询时，如果采用体积很小的基于哈希值的索引来查找，则性能会提升很多，唯一的缺点就是需要调用一个哈希函数，为此我们可以使用触发器来实现。</p><p>如果出现了哈希冲突，则查询会返回多行数据，为此在查询时还必须带上真正的URL常量值。正确的查询语句为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> xx <span class="token keyword">from</span> url<span class="token keyword">where</span> url_hash <span class="token operator">=</span> <span class="token keyword">hash</span><span class="token punctuation">(</span><span class="token string">'https://www.baidu.com/'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com/'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="优点">优点</h4><p>查询速度极快，平均为 <spanclass="math inline">\(\mathcal{O}(1)\)</span></p><h4 id="缺点">缺点</h4><ol type="1"><li>只能用于等值查询，如 =, !=,IN，由于本身的数据结构，像范围查询（BETWEEN），模糊查询（LIKE）都是用不了的</li><li>不能排序，哈希表是无序的</li><li>不支持部分索引列查询，如对（A，B）建立索引，若查询只有A，则无法用索引</li><li>仍需要回表查询<br />由于可能发生哈希冲突，需要将数据与数据库中的数据比较</li><li>哈希表负载因子高了，性能会降低</li></ol><p>所以其使用场景很小</p><h2 id="按物理存储分类">按物理存储分类</h2><p><strong>区别：</strong>聚簇索引节点存放行记录数据，而非聚簇索引存放指针</p><h3 id="聚簇索引">聚簇索引</h3><p>也称聚集索引，根据每张表的主键构造一颗 B+树，叶子结点存放行记录数据<br />InnoDB表要求必须有聚簇索引，默认在主键字段上建立聚簇索引，在没有主键字段的情况下，表的第一个非空的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，InnoDB将自动生成一个隐式的自增 id 列，并在此列上建立聚簇索引。 以 MyISAM为存储引擎的表不存在聚簇索引。</p><p><strong>优点：</strong></p><ol type="1"><li>速度快，因为其将数据直接存在结点上，少了一次查询</li><li>数据逻辑上连续（物理上不连续），区间查询很快<br />页间使用双向链表，页内使用单向链表来实现顺序性</li></ol><h3 id="非聚簇索引">非聚簇索引</h3><p>也称二级索引，辅助索引，叶子结点存放的是数据的指针</p><h2 id="按字段特性分类">按字段特性分类</h2><h3 id="普通索引">普通索引</h3><p>普通索引就是最最基础的索引，这种索引没有任何的约束作用，它存在的主要意义就是提高查询效率。</p><h3 id="唯一性索引">唯一性索引</h3><p>在普通索引的基础上加上唯一性约束</p><h3 id="主键索引">主键索引</h3><p>在唯一性索引的基础上加上非空约束</p><h3 id="全文索引">全文索引</h3><p>对内容进行分词， MySQL 中少用（5.6 版本后支持）</p><h3 id="前缀索引">前缀索引</h3><p>对字符类型字段的前几个字符或 bytes建立索引，而不是整个字段，大大减少索引占用空间，也提高了查找效率，关键在于建立多长的前缀使得查到的数据冲突少，但同时也会带来空间的开销</p><h2 id="按字段个数分类">按字段个数分类</h2><h3 id="单列索引">单列索引</h3><p>对单个列进行索引</p><h3 id="联合索引">联合索引</h3><p>对多个列进行索引，又称复合索引，组合索引，使用最左前缀原则匹配</p><p><strong>最左前缀原则</strong>：</p><p>进行匹配，必须按照组合索引从左往右添加 <code>where</code>条件，当遇到范围查询，如：&lt;, &gt;, between, like 等就会停止匹配</p><ol type="1"><li>像对 (a, b, c) 建立索引，查询条件 a / ab / abc 会走索引，使用 bc不会索引<br />因为 <code>a</code> 全局有序，<code>b</code> 是局部有序，只有<code>a</code> 确定了，<code>b</code> 才能有序</li><li>如 <code>where a=1 and b&gt;2 and c=3</code> 时，<code>b</code>进行了范围查找，此时 <code>c</code> 用不了索引</li></ol><h2 id="覆盖索引的情况">覆盖索引的情况</h2><p>当数据在二级索引且为联合索引中找到时，不需要回表查询，可以用Explain命令查看SQL语句的执行计划，执行计划的Extra字段中若出现Usingindex，表示查询触发了索引覆盖。</p><p>如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>student<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'自增主键'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8_bin <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'名称'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1'</span> <span class="token keyword">COMMENT</span> <span class="token string">'年龄'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>I_name<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">"小赵"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"小王"</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"小李"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"小陈"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> I_name_age<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> age <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'小李'</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>name, age</code> 组成联合索引，<code>where</code> 中对<code>name</code> 进行查找，<code>select</code> 返回<code>age</code>，其存在于联合索引，不需要回表，故为覆盖索引</p><h2 id="什么时候不该建立索引">什么时候不该建立索引？</h2><p>索引虽好，但由于本身会带来空间上的开销，增删改操作也会变慢，所以有一些情况不适合建立索引</p><ol type="1"><li>where 条件中用不到的字段不适合</li><li>表记录很少只有几百条</li><li>需要经常增删改，需要评估是否适合加索引</li><li>参与列计算的列不适合</li><li>区分度不高的字段不适合，如：性别（男，女，未知三个值），加了索引效率也不会太高，<code>select</code>会有多个值<br />ps：可以使用位图索引</li></ol><h2 id="参考">参考</h2><p><ahref="https://blog.csdn.net/weixin_43767015/article/details/119346481">MySQL哈希索引的数据结构以及索引的优缺点</a></p><p><ahref="https://segmentfault.com/a/1190000037683781">MySQL索引有哪些分类，你真的清楚吗？</a></p><p><a href="https://segmentfault.com/a/1190000020416577">B 树，B+树详解</a></p><p><ahref="https://juejin.cn/post/7078512620289916964">主键索引就是聚集索引？MySQL索引类型大梳理</a></p><p><ahref="https://www.cnblogs.com/lbser/p/3322630.html">位图（BitMap）索引</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 构造和析构的顺序</title>
      <link href="/posts/c-gou-zao-he-xi-gou-de-shun-xu/"/>
      <url>/posts/c-gou-zao-he-xi-gou-de-shun-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数调用顺序">构造函数调用顺序</h2><ol type="1"><li>调用虚基类构造函数（从左到右）</li><li>调用非虚基类构造函数（从左到右）</li><li>调用成员变量构造函数（按声明顺序从前往后，而非初始化列表顺序）</li><li>调用类自身构造函数的语句</li></ol><h2 id="析构函数调用顺序">析构函数调用顺序</h2><p>与构造函数相反</p><ol type="1"><li>执行自身析构函数语句</li><li>析构成员变量（从后往前）</li><li>调用非虚基类构造函数（从右到左）</li><li>调用虚基类构造函数（从右到左）</li></ol><h2 id="例子">例子</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Base1</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base1 ctor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Base1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base1 dtor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Base2</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base2 ctor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Base2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base2 dtor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">VBase</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">VBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"VBase ctor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">VBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"VBase dtor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A ctor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A dtor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B ctor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B dtor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Base2</span><span class="token punctuation">,</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">VBase</span></span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    A a<span class="token punctuation">;</span>    B b<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived ctor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived dtor"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Derived der<span class="token punctuation">;</span>    <span class="token comment">// Base1 *base = new Derived;</span>    <span class="token comment">// delete base;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">VBase ctorBase1 ctorBase2 ctorA ctorB ctorDerived ctorDerived dtorB dtorA dtorBase2 dtorBase1 dtorVBase dtor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完全符合规则</p><h2 id="多态的基类析构函数要声明为-virtual">多态的基类析构函数要声明为virtual</h2><p>下面如果使用 <code>Base1 *base = new Derived; delete base;</code>呢</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">VBase ctorBase1 ctorBase2 ctorA ctorB ctorDerived ctorBase1 dtor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思考哪出了问题？</p><p>其实是为了实现多态，则必须声明基类的析构函数为<code>virtual</code>，本题可以将 <code>Base1</code> 的析构函数声明为<code>virtual</code></p><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">VBase ctorBase1 ctorBase2 ctorA ctorB ctorDerived ctorDerived dtorB dtorA dtorBase2 dtorBase1 dtorVBase dtor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>僵尸进程与孤儿进程</title>
      <link href="/posts/jiang-shi-jin-cheng-yu-gu-er-jin-cheng/"/>
      <url>/posts/jiang-shi-jin-cheng-yu-gu-er-jin-cheng/</url>
      
        <content type="html"><![CDATA[<p>什么是僵尸进程，什么是孤儿进程，会带来什么问题，如何解决？</p><h2 id="基本概念">基本概念</h2><p>子进程由父进程创建，而子进程和父进程的运行是异步的，谁也不确定谁先运行，当子进程完成工作时，父进程需要使用<code>wait</code> 或 <code>waitpid</code> 来获取子进程终止状态</p><h2 id="孤儿进程">孤儿进程 👶</h2><h3 id="产生原因">产生原因</h3><p>父进程先于子进程退出（没有使用 <code>wait</code> 或<code>waitpid</code>），子进程还在运行，则这些子进程会变成孤儿进程，将被init 进程（pid 为 1）收养，并由 init 对其进行状态收集</p><h3 id="危害">危害</h3><p>孤儿进程由 init 进程收养，并不会有什么危害</p><h3 id="代码">代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 对于 fork，父进程返回子进程 pid，子进程返回 0，失败返回 -1</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Fork Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm the child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid: %d\tppid: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保此时父进程已退出，被 init 进程收养</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid: %d\tppid: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process is exited\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm the father process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保子进程先输出当前的 ppid</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father process is exited\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">I'm the father processI'm the child processpid: 27788      ppid: 27787father process is exitedpid: 27788      ppid: 1child process is exited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="僵尸进程">僵尸进程 🧟‍♀️</h2><h3 id="产生原因-1">产生原因</h3><p>子进程退出，父进程没有调用 <code>wait</code> 或 <code>waitpid</code>获取子进程状态，则子进程的进程描述符会一直占用，被称为僵尸进程</p><h3 id="危害-1">危害</h3><p>僵尸进程的进程描述符会一直占用，如产生大量僵尸进程会导致可用的 pid大量减少，甚至不能产生新进程，且会占用空间</p><h3 id="解决方案">解决方案</h3><p>僵尸进程的罪魁祸首是不回收子进程的父进程，可以 <code>kill</code> 发送<code>SIGKILL</code> 或 <code>SIGTERM</code> 来枪毙他，让 init进程回收这些孤儿进程，使这些僵死的孤儿进程瞑目</p><h3 id="代码-1">代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 对于 fork，父进程返回子进程 pid，子进程返回 0，失败返回 -1</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Fork Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm the child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid: %d\tppid: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process is exited\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I'm the father process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保子进程先输出当前的 ppid</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"ps -o pid,ppid,state,tty,command | grep zombie | grep -v grep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father process is exited\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">I'm the father processI'm the child processpid: 30196      ppid: 30195child process is exited30195 11875 S+   ttys008  /Users/world/code/tmp/zombie30196 30195 Z+   ttys008  (zombie)father process is exited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大量产生僵尸进程</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 对于 fork，父进程返回子进程 pid，子进程返回 0，失败返回 -1</span>        pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Fork Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am a child process.\nI am exiting.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保子进程先输出当前的 ppid</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"ps -o pid,ppid,state,tty,command | grep zombie | grep -v grep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">I am a child process.I am exiting.30960 11875 S+   ttys008  /Users/world/code/tmp/zombie230965 30960 Z+   ttys008  (zombie2)I am a child process.I am exiting.30960 11875 S+   ttys008  /Users/world/code/tmp/zombie230965 30960 Z+   ttys008  (zombie2)30974 30960 Z+   ttys008  (zombie2)I am a child process.I am exiting.30960 11875 S+   ttys008  /Users/world/code/tmp/zombie230965 30960 Z+   ttys008  (zombie2)30974 30960 Z+   ttys008  (zombie2)30983 30960 Z+   ttys008  (zombie2)I am a child process.I am exiting.30960 11875 S+   ttys008  /Users/world/code/tmp/zombie230965 30960 Z+   ttys008  (zombie2)30974 30960 Z+   ttys008  (zombie2)30983 30960 Z+   ttys008  (zombie2)30992 30960 Z+   ttys008  (zombie2)I am a child process.I am exiting.30960 11875 S+   ttys008  /Users/world/code/tmp/zombie230965 30960 Z+   ttys008  (zombie2)30974 30960 Z+   ttys008  (zombie2)30983 30960 Z+   ttys008  (zombie2)30992 30960 Z+   ttys008  (zombie2)31001 30960 Z+   ttys008  (zombie2)I am a child process.I am exiting.30960 11875 S+   ttys008  /Users/world/code/tmp/zombie230965 30960 Z+   ttys008  (zombie2)30974 30960 Z+   ttys008  (zombie2)30983 30960 Z+   ttys008  (zombie2)30992 30960 Z+   ttys008  (zombie2)31001 30960 Z+   ttys008  (zombie2)31014 30960 Z+   ttys008  (zombie2)I am a child process.I am exiting.30960 11875 S+   ttys008  /Users/world/code/tmp/zombie230965 30960 Z+   ttys008  (zombie2)30974 30960 Z+   ttys008  (zombie2)30983 30960 Z+   ttys008  (zombie2)30992 30960 Z+   ttys008  (zombie2)31001 30960 Z+   ttys008  (zombie2)31014 30960 Z+   ttys008  (zombie2)31023 30960 Z+   ttys008  (zombie2)I am a child process.I am exiting.^C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后使用 Ctrl-C 退出，僵尸进程被 init 收养释放，也可以使用<code>kill -9 &lt;pid&gt;</code></p><h2 id="总结">总结</h2><p>无论是孤儿进程还是僵尸进程产生的原因都是父进程没有 <code>wait</code>或<code>waitpid</code>，区别在于孤儿进程是父进程先走，僵尸进程是子进程先走</p><h2 id="参考">参考</h2><p><ahref="https://www.cnblogs.com/anker/p/3271773.html">孤儿进程与僵尸进程[总结]</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈网络 I/O</title>
      <link href="/posts/qian-tan-wang-luo-i-o/"/>
      <url>/posts/qian-tan-wang-luo-i-o/</url>
      
        <content type="html"><![CDATA[<p>面试问到网络或者 Redis 时常考题</p><h2 id="基本概念">基本概念</h2><h3 id="socket">Socket</h3><p>套接字，用于网络中不同主机上应用程序间双向通信的端点的抽象，他将复杂的TCP/IP 隐藏在 Socket 接口后面</p><ul><li>Socket 地址 = IP 地址:端口号</li><li>不同的协议，如 TCP，UDP 可同时使用相同端口号</li></ul><p><img src="1.jpeg" alt="什么是 Socket" /></p><p><img src="2.jpeg" alt="Socket 通信流程" /></p><p>对具体使用感兴趣的可以做下这个实验 <ahref="https://gaia.cs.umass.edu/kurose_ross/programming.php">计算机网络自顶向下Lab</a>，很有意思</p><h3 id="fdfile-descriptor">FD(File Descriptor)</h3><p>文件描述符，为非负整数，Linux中一切资源都可以通过文件来访问和管理，FD 用于指向某一资源</p><h3 id="阻塞与非阻塞">阻塞与非阻塞</h3><p>阻塞与非阻塞，描述调用者在等待返回结果的过程</p><ul><li>阻塞：调用者发送请求后，会一直等待返回结果，当前线程被阻塞</li><li>非阻塞：调用者发送请求后，会立刻返回，当前线程不会阻塞，但调用需要定期轮询（一个个看）查看处理结果</li></ul><p>例子：</p><p>阻塞/非阻塞：我在等你干活的时候我在干啥？</p><ul><li>阻塞：啥也不干，死等</li><li>非阻塞：可以干别的，但也要时不时问问你的进度</li></ul><h3 id="同步与异步">同步与异步</h3><p>而同步与异步，用于描述调用结果的返回机制（或者叫通信机制）。</p><ul><li>同步：调用者发起请求后，会一直等待返回结果，即由调用者主动等待这个调用结果。</li><li>异步：调用者发起请求后，会立刻返回，但不会立刻得到这个结果，而是由被调者在执行结束后主动通知（如Callback）调用者。</li></ul><p>例子：</p><p>同步/异步：你干完了，怎么让我知道呢？</p><ul><li>同步：我只要不问，你就不告诉我</li><li>异步：你干完了，直接喊我过来就行</li></ul><p>以上的IO可以组合成4种组合方式：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞</p><h3 id="用户态和内核态">用户态和内核态</h3><p>两种不同的权限等级</p><h4 id="用户态">用户态</h4><p>只能执行系统规定的指令，当需要执行某些系统特权指令（系统调用）时，需要切换到内核态<img src="8.png" alt="系统调用位置" /></p><h4 id="内核态">内核态</h4><p>能够执行特权指令，如：IO，内存分配等对硬件操作的指令</p><h2 id="五种-io-模型">五种 I/O 模型</h2><p><img src="9.png" alt="五种 I/O 模型" /></p><h3 id="阻塞-io">阻塞 I/O</h3><p>优点：程序简单，线程挂起不会占用 CPU 资源<br />缺点：在高并发场景下，需要大量线程，那内存，线程切换开销是不可接受的<br />总之：不常用</p><h3 id="非阻塞-io">非阻塞 I/O</h3><p>优点：线程立刻返回，可以干别的活<br />缺点：不断轮询效率低，数据到达和轮询有时间差，所以响应延迟高<br />总之：不常用，最多使用非阻塞 I/O 的特性</p><h3 id="io-多路复用">I/O 多路复用</h3><p>Redis 作为一个单线程的数据库，使用的就是 I/O 多路复用</p><blockquote><p><strong>Redis 快的原因？</strong></p><ol type="1"><li>基于内存操作<br /></li><li>数据结构简单<br /></li><li>I/O 多路复用<br /></li><li>主线程为单线程，避免上下文切换</li></ol></blockquote><p>unix 的 select()，poll()，linux 的 epoll()系列都是同步非阻塞，windows 的 IOCP 是异步非阻塞</p><p><img src="3.png" alt="三种多路复用区别" /> 优点：一个线程复用多个Socket，避免了多线程创建，切换，销毁的开销</p><h4 id="select">select</h4><p><a href="https://man7.org/linux/man-pages/man2/select.2.html">API文档</a> <img src="4.png" alt="select" /></p><p>优点：解决了线程切换的问题<br />缺点：</p><ul><li>FD 最大默认为 1024</li><li>每次调用需要将 FD 从用户态拷贝到内核态</li><li>不知道哪个 FD 就绪，需要全部遍历</li><li>参数每次调用都要重置（因为 <code>readfds, writefds, exceptfds</code>要作为返回值）</li></ul><h4 id="poll">poll</h4><p><a href="https://man7.org/linux/man-pages/man2/poll.2.html">API文档</a> <img src="5.png" alt="poll" /></p><p>优点：解决了线程切换的问题<br />缺点：</p><ul><li><del>FD 最大默认为 1024</del></li><li>每次调用需要将 FD 从用户态拷贝到内核态</li><li>不知道哪个 FD 就绪，需要全部遍历</li><li><del>参数每次调用都要重置（因为<code>readfds, writefds, exceptfds</code> 要作为返回值）</del></li></ul><h4 id="epoll">epoll</h4><p><a href="https://man7.org/linux/man-pages/man7/epoll.7.html">API文档</a> <img src="6.png" alt="epoll-1" /> <img src="7.png"alt="epoll-2" /></p><p>LT：Level-Triggered，水平触发（默认），<code>epoll_wait</code>检测到事件后，如该事件没有处理完毕，后续 <code>epoll_wait</code>都会返回该事件，更安全<br />ET：Edge-Triggered，边缘触发，<code>epoll_wait</code>检测到事件后，只会在当次返回，不管该事件是否被处理完毕，更快</p><p>优点：解决了线程切换的问题<br />缺点：</p><ul><li><del>FD 最大默认为 1024</del></li><li><del>每次调用需要将 FD 从用户态拷贝到内核态</del></li><li><del>不知道哪个 FD 就绪，需要全部遍历</del></li><li><del>参数每次调用都要重置（因为<code>readfds, writefds, exceptfds</code> 要作为返回值）</del></li><li>跨平台不好，只支持 Linux</li><li>相比较 select，epoll 太重了，遇到监听连接数和事件较少的场景，select可能更优</li></ul><h3 id="异步-io">异步 I/O</h3><p>一般为非堵塞，除非刻意堵塞<br />应用进程执行 aio_read系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><h3 id="信号驱动-io">信号驱动 I/O</h3><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接口几乎是没用的，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么事情</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p><img src="10.png" alt="比较" /></p><h2 id="总结">总结</h2><p>本文介绍了 I/O 操作的基本概念，常见 I/O的五种模型，多路复用的三种方式</p><p><strong>最后提几个问题供读者检验成果：</strong></p><ol type="1"><li>阻塞和非阻塞有何区别，取决于什么？</li><li>同步和异步有何区别？</li><li>select，poll，epoll 有何区别？</li><li>Redis 为什么快？</li><li>同一个端口可以同时给 TCP 程序和 UDP 程序使用吗？</li><li>I/O 五个模型分别是什么？</li><li>socket 是什么，socket 地址是什么？</li></ol><h2 id="参考">参考</h2><p><a href="https://blog.ixk.me/post/talking-about-io">浅谈IO |青空之蓝</a><br /><a href="https://b23.tv/a9eq4SR">小白也看得懂的 I/O多路复用解析（超详细案例）-哔哩哔哩</a><br /><ahref="https://segmentfault.com/a/1190000039898780#:~:text=IO%20%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%8C%87%EF%BC%9A%E7%94%A8,%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%BC%82%E6%AD%A5IO%20%E6%A8%A1%E5%9E%8B%E3%80%82">浅聊Linux的五种IO模型</a><br /><ahref="https://xmmarlowe.github.io/2021/06/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/">用户态和内核态</a><br /><ahref="https://segmentfault.com/a/1190000041488709#:~:text=%E6%89%80%E8%B0%93%E7%9A%84I%2FO%E5%A4%9A,%E6%97%A0%E9%9C%80%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E3%80%82">深入理解redis——Redis快的原因和IO多路复用深度解析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 实现高性能内存池</title>
      <link href="/posts/c-shi-xian-gao-xing-neng-nei-cun-chi/"/>
      <url>/posts/c-shi-xian-gao-xing-neng-nei-cun-chi/</url>
      
        <content type="html"><![CDATA[<p>本篇文章将介绍内存池的原理以及实现<br />项目链接：<a class="theme-btn" href="https://github.com/cs-moushuai/MemoryPool" title="GitHub"><i class="fab fa-github fa-fw fa-lg"></i>GitHub</a></p><h2 id="什么是内存池">什么是内存池？</h2><p>内存池和线程池类似，一次申请大量的内存，程序需要内存就从池子里拿，析构就将内存放回池子里</p><h2 id="内存池的优缺点">内存池的优缺点</h2><h3 id="优点">优点</h3><ol type="1"><li>速度快，因为内存池绝大部分情况下是用户态、无锁、O(1)或O(logN)的时间复杂度，所以速度会比malloc/free要快很多。</li><li>避免内存碎片，频繁且不规律的malloc/free，尤其是大量小对象的时候，可能会导致内存释放后，空闲的内存块被已分配的内存块分割成无法合并的多块小“碎块”。此时突然申请一块大内存，虽然总的空闲内存大小是足够的，但我们却无法利用它们来完成内存分配。</li><li>增加内存的利用率，由于malloc在分配内存时，需要增加一些必要的簿记信息，也就是记录内存块信息的头部结构，因此每次内存分配都会导致一定程度的浪费。而内存池不同，可以做到按需分配。使用得当的话内存浪费会很小。</li></ol><h3 id="缺点">缺点</h3><p>使用内存池的缺点是会导致一定程度上的编程复杂度增加。不同方法实现的内存池有各自在使用上需要注意的地方，随随便便的用可能会引起意料之外的问题。</p><h2 id="什么时候使用内存池">什么时候使用内存池？</h2><p>当程序需要频繁在堆上申请和释放内存时</p><h2 id="内存池原理">内存池原理</h2><p>内存池的思想是，在真正使用内存之前，预先申请分配一定数量、大小预设的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存，当内存释放后就回归到内存块留作后续的复用，使得内存使用效率得到提升，一般也不会产生不可控制的内存碎片。</p><h3 id="结构">结构</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> Slot_ <span class="token punctuation">&#123;</span>    value_type element<span class="token punctuation">;</span> <span class="token comment">// 内存池内部元素类型</span>    Slot_<span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">// 指向下一个 block</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">char</span><span class="token operator">*</span>               data_pointer_<span class="token punctuation">;</span><span class="token keyword">typedef</span> Slot_               slot_type_<span class="token punctuation">;</span><span class="token keyword">typedef</span> Slot_<span class="token operator">*</span>              slot_pointer_<span class="token punctuation">;</span>slot_pointer_ currentBlock_<span class="token punctuation">;</span> <span class="token comment">// 指向当前块</span>slot_pointer_ currentSlot_<span class="token punctuation">;</span> <span class="token comment">// 指向当前块的 ele</span>slot_pointer_ lastSlot_<span class="token punctuation">;</span> <span class="token comment">// 指向当前块的最后一个 ele</span>slot_pointer_ freeSlots_<span class="token punctuation">;</span> <span class="token comment">// 释放的空间都存在空闲链表中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义了一个联合体，可以表现为元素，也可以表现为下一个 block 的指针</p><p><img src="memory_pool.001.jpeg" alt="内存池结构" /></p><p>其中 Next 指向下一个 Block（每个块默认大小为 4096B），Pad 为 Block减去 Next 后剩余大小对 ele 类型大小取模的结果，最后有若干个 ele 元素</p><h3 id="申请空间">申请空间</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">allocateBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 分配新 Block</span>    data_pointer_ newBlock <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>data_pointer_<span class="token operator">></span></span></span>                            <span class="token punctuation">(</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>BlockSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 头插法</span>    <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>newBlock<span class="token punctuation">)</span><span class="token operator">-></span>next <span class="token operator">=</span> currentBlock_<span class="token punctuation">;</span>    currentBlock_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>newBlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保留一个大小指向下一个区块的地址，计算 body 位置</span>    <span class="token comment">// 用 currentBlock_ 要类型转换</span>    data_pointer_ body <span class="token operator">=</span> newBlock <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>slot_pointer_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算 body 中填充位置</span>    size_type padding <span class="token operator">=</span> <span class="token function">padPointer</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>slot_type_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// currentSlot_ 指向（body+padding）头，lastSlot_ 指向最后一个位置地址 +1</span>    currentSlot_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>body <span class="token operator">+</span> padding<span class="token punctuation">)</span><span class="token punctuation">;</span>    lastSlot_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span>                <span class="token punctuation">(</span>newBlock <span class="token operator">+</span> BlockSize <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>slot_type_<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> <span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span>pointer<span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_type n<span class="token punctuation">,</span> const_pointer hint<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>freeSlots_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pointer res <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>pointer<span class="token operator">></span></span></span><span class="token punctuation">(</span>freeSlots_<span class="token punctuation">)</span><span class="token punctuation">;</span>        freeSlots_ <span class="token operator">=</span> freeSlots_<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// todo 为什么优先使用 freeSlot_ 中的块，那当前的块不就浪费了吗</span>        <span class="token comment">// answer：freeSlots 存放的是 slot 不是 block，不影响当前块</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentSlot_ <span class="token operator">>=</span> lastSlot_<span class="token punctuation">)</span>            <span class="token function">allocateBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>pointer<span class="token operator">></span></span></span><span class="token punctuation">(</span>currentSlot_<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>申请空间先在空闲链表中找，若没有再再当前块中找，若用完了就去申请一个新块，分配新块中要注意填充空间，且分配空间用的是placement new，即只申请不构造而 new 是先申请后构造</p><p>placement new</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">data_pointer_ newBlock <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>data_pointer_<span class="token operator">></span></span></span>                            <span class="token punctuation">(</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>BlockSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在申请的空间上 construct</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span><span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">construct</span><span class="token punctuation">(</span>U<span class="token operator">*</span> p<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// todo 为什么类型是 U 不是 T</span>    <span class="token comment">// answer：U 是 value_type，本质也是 T</span>    <span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token function">U</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">></span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="释放空间">释放空间</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 释放单个元素</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span><span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>pointer p<span class="token punctuation">,</span> size_type n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-></span>next <span class="token operator">=</span> freeSlots_<span class="token punctuation">;</span>        freeSlots_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 析构单个元素</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span><span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">destroy</span><span class="token punctuation">(</span>U<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        p<span class="token operator">-></span><span class="token operator">~</span><span class="token function">U</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 按块释放</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span>MemoryPool<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">MemoryPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 不要写 currentSlot_ 会将值当作地址</span>    slot_pointer_ curr <span class="token operator">=</span> currentBlock_<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        slot_pointer_ t <span class="token operator">=</span> curr<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">// 转化为 void* 避免调用 dtor</span>        <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curr <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>释放元素：先调用 <code>destroy</code> 后调用<code>deallocate</code><br />释放内存池：<code>~MemoryPool()</code></p><h3 id="移动">移动</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span>MemoryPool<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token operator">&amp;</span>MemoryPool<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MemoryPool <span class="token operator">&amp;&amp;</span>rhs<span class="token punctuation">)</span><span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>currentBlock_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>currentBlock_<span class="token punctuation">)</span><span class="token punctuation">;</span>        currentSlot_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>currentSlot_<span class="token punctuation">;</span>        lastSlot_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>lastSlot_<span class="token punctuation">;</span>        freeSlots_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>freeSlots_<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：移动相关的函数都是 <code>noexcept</code>的，因为移动后原对象就可能损毁，不能进行第二次移动，另外非移动的且能保证一定不抛出异常的也可以用<code>noexcept</code> 来提高性能</p><h2 id="测试">测试</h2><p>链表栈的 <code>push</code> 和 <code>pop</code> 操作</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 入栈</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">StackAlloc</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">push</span><span class="token punctuation">(</span>T element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 为一个节点分配内存</span>    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> allocator_<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用节点的构造函数</span>    allocator_<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 入栈操作</span>    newNode<span class="token operator">-></span>data <span class="token operator">=</span> element<span class="token punctuation">;</span>    newNode<span class="token operator">-></span>prev <span class="token operator">=</span> head_<span class="token punctuation">;</span>    head_ <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 出栈</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Alloc</span><span class="token operator">></span>T <span class="token class-name">StackAlloc</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 出栈操作 返回出栈元素</span>    T result <span class="token operator">=</span> head_<span class="token operator">-></span>data<span class="token punctuation">;</span>    Node<span class="token operator">*</span> tmp <span class="token operator">=</span> head_<span class="token operator">-></span>prev<span class="token punctuation">;</span>    allocator_<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>head_<span class="token punctuation">)</span><span class="token punctuation">;</span>    allocator_<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>head_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head_ <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ELEMS</span> <span class="token expression"><span class="token number">10000000</span></span></span><span class="token comment">// 重复次数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPS</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    clock_t start<span class="token punctuation">;</span>    <span class="token comment">// 使用 STL 默认分配器</span>    StackAlloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> stackDefault<span class="token punctuation">;</span>    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> REPS<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>stackDefault<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ELEMS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            stackDefault<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ELEMS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            stackDefault<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Default Allocator Time: "</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" s\n\n"</span><span class="token punctuation">;</span>    <span class="token comment">// 使用内存池</span>    StackAlloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> MemoryPool<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> stackPool<span class="token punctuation">;</span>    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> REPS<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>stackPool<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ELEMS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            stackPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ELEMS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            stackPool<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MemoryPool Allocator Time: "</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" s\n\n"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过链表栈的频繁 <code>push</code> 和 <code>pop</code>操作来测试性能</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Default Allocator Time: 59.2128 sMemoryPool Allocator Time: 12.0348 s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="总结">总结</h2><p>通过这个项目收获了内存分配的相关知识，对于 C++的相关特性，如模板，面向对象，可变参数，性能测试都有涉猎<br />最后这个项目也可以用单例模式来实现，这样整个程序就只有一个实例了，可以进一步调高性能，留给读者思考</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归 vs 迭代</title>
      <link href="/posts/di-gui-vs-die-dai/"/>
      <url>/posts/di-gui-vs-die-dai/</url>
      
        <content type="html"><![CDATA[<p>首先提出两个问题</p><ul><li>所有递归都可以改写成循环吗？</li><li>改写后会有什么好处？</li></ul><p>接下来我们仔细分析下具体的区别</p><h2 id="递归转换为迭代的方法">递归转换为迭代的方法</h2><p>对于递归而言有两种转换方式</p><h3 id="一直接转换法">一、直接转换法</h3><p><strong>方法</strong>：使用变量保存中间结果</p><p>计算阶乘：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>　　<span class="token keyword">else</span> <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>　　<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>　      res <span class="token operator">*=</span> i<span class="token punctuation">;</span>　　<span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，时间复杂度依旧为 <spanclass="math inline">\(\mathcal{O}(n)\)</span>，但空间复杂度已经从 <spanclass="math inline">\(\mathcal{O}(n) \to \mathcal{O}(1)\)</span>了，因为原本需要调用 <code>fact(...)</code> <spanclass="math inline">\(n\)</span> 次，但现在只需要 <spanclass="math inline">\(1\)</span> 次了</p><h3 id="二间接转换法">二、间接转换法</h3><p><strong>方法</strong>：使用栈保存中间结果</p><p>树的先序遍历：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        TreeNode <span class="token operator">*</span>p<span class="token operator">=</span>root<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>p<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但此处的时间和空间复杂度却都没有变化，因为用栈来保存结果，本质就是在模拟函数调用的过程，并没有什么好处，但编写代码的难度却大大提高</p><p>所以，回答下开头的问题</p><h2 id="所有递归都可以改写成循环吗">所有递归都可以改写成循环吗？</h2><p>是的，所有递归都使用直接或间接的方式转换</p><h2 id="改写后会有什么好处">改写后会有什么好处？</h2><p>使用直接转换可以避免空间上的开销，使用间接转换本质在模拟函数调用没有意义</p><h2 id="总结">总结</h2><p>虽然递归有着很大的空间开销，但很多时候我们是很难用迭代写出我们想要的程序，而且空间上的开销也不是很重要，相比较迭代的自底向上，递归的自顶向下往往更符合人类的逻辑，很多时候做动态规划的题目没有思路的时候，都可以考虑用自顶向下的记忆化搜索来完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锂电池保养手册</title>
      <link href="/posts/li-dian-chi-bao-yang-shou-ce/"/>
      <url>/posts/li-dian-chi-bao-yang-shou-ce/</url>
      
        <content type="html"><![CDATA[<p>为什么有的人电池用了半年还有 <strong>100%</strong>，而有的人就剩下<strong>90%</strong> 了呢？</p><h2 id="原则">原则</h2><p>电池充电可以比喻成人吃饭，尽量少吃多餐</p><h2 id="现代锂电池充电规则">现代锂电池充电规则</h2><p><img src="1.jpeg" alt="放电流程" /></p><h2 id="注意点">注意点</h2><ol type="1"><li>避免在 <strong>20%</strong> 以下使用，尤其是 <strong>5%</strong>以下</li><li>电量保存在 <strong>25%-75%</strong></li><li>避免高温低温时使用，建议在 <strong>16-22度</strong> 间最好</li><li>高温时避免边冲边玩，快充也会提高温度，锂电池高温掉容量</li><li>长时间不用的电池要定时充电到 <strong>50%</strong>（每个6月）无电导致电池可能再也无法充电，满电可能导致容量下降</li><li>一个月进行一次充电循环，方法是将电池电量用到 <strong>15%</strong>左右，然后充满，就可以完成一次循环了</li></ol><blockquote><p>ps:一般设备，如macbook知道你经常充电就会将battery维持在80%以维持电压</p></blockquote><h2 id="电量对性能的影响">电量对性能的影响</h2><p>电量降低也会影响性能，而对于那些电池容量已经低于 <strong>80%</strong>的iPhone来说，影响体验的话，还是尽早换块新电池吧。</p><p>毕竟，在需要更极端的性能管理的情况下，体验上可能会受到影响，用苹果的话来说：</p><ul><li>应用启动时间变长</li><li>滚动时帧速率降低</li><li>背光灯变暗（可在“控制中心”手动调整）</li><li>扬声器音量降低幅度高达 -3dB</li><li>部分应用的帧速率逐渐降低</li><li>在最极端的情况下，相机闪光灯会被停用（会显示在相机用户界面上）</li><li>在后台刷新的应用在启动时可能需要重新载入</li></ul><h2 id="faq">FAQ</h2><h3 id="电池维持在-25-到-75-对电池好有这个说法吗">电池维持在 25 到 75对电池好，有这个说法吗？</h3><p>对的，因为高压低压对电池都不好</p><h3 id="电池会过冲吗">电池会过冲吗？</h3><p>不会，终端产品的锂电池都是双重保护的，适配器一个保护板，电池有一个保护板，超过保护板的最低电压它就停止放电了，充电同原理。基本不会存在过冲过放的问，但高压对电池不好<img src="2.png" alt="充电流程" /></p><h2 id="总结">总结</h2><p>电池是消耗品，换一个也就几百，必要的时候该怎么用就怎么用，如果真的想保护好电池，最简单的保障电量<strong>25%-75%</strong>，如果是 iphone的话，开启手机的优化充电模式，这样在你睡觉的时候大部分时间电量会保持在<strong>75%</strong>，且不要在手机温度过高的时候充电就够了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数码 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
