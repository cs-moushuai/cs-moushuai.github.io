<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>递归 vs 迭代</title>
      <link href="/2022/08/24/di-gui-vs-die-dai/"/>
      <url>/2022/08/24/di-gui-vs-die-dai/</url>
      
        <content type="html"><![CDATA[<p>首先提出两个问题</p><ul><li>所有递归都可以改写成循环吗？</li><li>改写后会有什么好处？</li></ul><p>接下来我们仔细分析下具体的区别</p><h2 id="递归转换为迭代的方法">递归转换为迭代的方法</h2><p>对于递归而言有两种转换方式</p><h3 id="一直接转换法">一、直接转换法</h3><p><strong>方法</strong>：使用变量保存中间结果</p><p>计算阶乘：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>　　<span class="token keyword">else</span> <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>　　<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>　      res <span class="token operator">*=</span> i<span class="token punctuation">;</span>　　<span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，时间复杂度依旧为 <spanclass="math inline">\(\mathcal{O}(n)\)</span>，但空间复杂度已经从 <spanclass="math inline">\(\mathcal{O}(n) \to \mathcal{O}(1)\)</span>了，因为原本需要调用 <code>fact(...)</code> <spanclass="math inline">\(n\)</span> 次，但现在只需要 <spanclass="math inline">\(1\)</span> 次了</p><h3 id="二间接转换法">二、间接转换法</h3><p><strong>方法</strong>：使用栈保存中间结果</p><p>树的先序遍历：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        TreeNode <span class="token operator">*</span>p<span class="token operator">=</span>root<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>p<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但此处的时间和空间复杂度却都没有变化，因为用栈来保存结果，本质就是在模拟函数调用的过程，并没有什么好处，但编写代码的难度却大大提高</p><p>所以，回答下开头的问题</p><h2 id="所有递归都可以改写成循环吗">所有递归都可以改写成循环吗？</h2><p>是的，所有递归都使用直接或间接的方式转换</p><h2 id="改写后会有什么好处">改写后会有什么好处？</h2><p>使用直接转换可以避免空间上的开销，使用间接转换本质在模拟函数调用没有意义</p><h2 id="总结">总结</h2><p>虽然递归有着很大的空间开销，但很多时候我们是很难用迭代写出我们想要的程序，而且空间上的开销也不是很重要，相比较迭代的自底向上，递归的自顶向下往往更符合人类的逻辑，很多时候做动态规划的题目没有思路的时候，都可以考虑用自顶向下的记忆化搜索来完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锂电池保养手册</title>
      <link href="/2022/08/23/li-dian-chi-bao-yang-shou-ce/"/>
      <url>/2022/08/23/li-dian-chi-bao-yang-shou-ce/</url>
      
        <content type="html"><![CDATA[<p>为什么有的人电池用了半年还有 <strong>100%</strong>，而有的人就剩下<strong>90%</strong> 了呢？</p><h2 id="原则">原则</h2><p>电池充电可以比喻成人吃饭，尽量少吃多餐</p><h2 id="现代锂电池充电规则">现代锂电池充电规则</h2><p><img src="1.jpeg" alt="放电流程" /></p><h2 id="注意点">注意点</h2><ol type="1"><li>避免在 <strong>20%</strong> 以下使用，尤其是 <strong>5%</strong>以下</li><li>电量保存在 <strong>25%-75%</strong></li><li>避免高温低温时使用，建议在 <strong>16-22度</strong> 间最好</li><li>高温时避免边冲边玩，快充也会提高温度，锂电池高温掉容量</li><li>长时间不用的电池要定时充电到 <strong>50%</strong>（每个6月）无电导致电池可能再也无法充电，满电可能导致容量下降</li><li>一个月进行一次充电循环，方法是将电池电量用到 <strong>15%</strong>左右，然后充满，就可以完成一次循环了</li></ol><blockquote><p>ps:一般设备，如macbook知道你经常充电就会将battery维持在80%以维持电压</p></blockquote><h2 id="电量对性能的影响">电量对性能的影响</h2><p>电量降低也会影响性能，而对于那些电池容量已经低于 <strong>80%</strong>的iPhone来说，影响体验的话，还是尽早换块新电池吧。</p><p>毕竟，在需要更极端的性能管理的情况下，体验上可能会受到影响，用苹果的话来说：</p><ul><li>应用启动时间变长</li><li>滚动时帧速率降低</li><li>背光灯变暗（可在“控制中心”手动调整）</li><li>扬声器音量降低幅度高达 -3dB</li><li>部分应用的帧速率逐渐降低</li><li>在最极端的情况下，相机闪光灯会被停用（会显示在相机用户界面上）</li><li>在后台刷新的应用在启动时可能需要重新载入</li></ul><h2 id="faq">FAQ</h2><h3 id="电池维持在-25-到-75-对电池好有这个说法吗">电池维持在 25 到 75对电池好，有这个说法吗？</h3><p>对的，因为高压低压对电池都不好</p><h3 id="电池会过冲吗">电池会过冲吗？</h3><p>不会，终端产品的锂电池都是双重保护的，适配器一个保护板，电池有一个保护板，超过保护板的最低电压它就停止放电了，充电同原理。基本不会存在过冲过放的问，但高压对电池不好<img src="2.png" alt="充电流程" /></p><h2 id="总结">总结</h2><p>电池是消耗品，换一个也就几百，必要的时候该怎么用就怎么用，如果真的想保护好电池，最简单的保障电量<strong>25%-75%</strong>，如果是 iphone的话，开启手机的优化充电模式，这样在你睡觉的时候大部分时间电量会保持在<strong>75%</strong>，且不要在手机温度过高的时候充电就够了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数码 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
