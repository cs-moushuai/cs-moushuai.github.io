<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈网络 I/O</title>
      <link href="/2022/09/01/qian-tan-wang-luo-i-o/"/>
      <url>/2022/09/01/qian-tan-wang-luo-i-o/</url>
      
        <content type="html"><![CDATA[<p>面试问到网络或者 Redis 时常考题</p><h2 id="基本概念">基本概念</h2><h3 id="socket">Socket</h3><p>套接字，用于网络中不同主机上应用程序间双向通信的端点的抽象，他将复杂的TCP/IP 隐藏在 Socket 接口后面</p><ul><li>Socket 地址 = IP 地址:端口号</li><li>不同的协议，如 TCP，UDP 可同时使用相同端口号</li></ul><p><img src="1.jpeg" alt="什么是 Socket" /></p><p><img src="2.jpeg" alt="Socket 通信流程" /></p><p>对具体使用感兴趣的可以做下这个实验 <ahref="https://gaia.cs.umass.edu/kurose_ross/programming.php">计算机网络自顶向下Lab</a>，很有意思</p><h3 id="fdfile-descriptor">FD(File Descriptor)</h3><p>文件描述符，为非负整数，Linux中一切资源都可以通过文件来访问和管理，FD 用于指向某一资源</p><h3 id="阻塞与非阻塞">阻塞与非阻塞</h3><p>阻塞与非阻塞，描述调用者在等待返回结果的过程</p><ul><li>阻塞：调用者发送请求后，会一直等待返回结果，当前线程被阻塞</li><li>非阻塞：调用者发送请求后，会立刻返回，当前线程不会阻塞，但调用需要定期轮询（一个个看）查看处理结果</li></ul><p>例子：</p><p>阻塞/非阻塞：我在等你干活的时候我在干啥？</p><ul><li>阻塞：啥也不干，死等</li><li>非阻塞：可以干别的，但也要时不时问问你的进度</li></ul><h3 id="同步与异步">同步与异步</h3><p>而同步与异步，用于描述调用结果的返回机制（或者叫通信机制）。</p><ul><li>同步：调用者发起请求后，会一直等待返回结果，即由调用者主动等待这个调用结果。</li><li>异步：调用者发起请求后，会立刻返回，但不会立刻得到这个结果，而是由被调者在执行结束后主动通知（如Callback）调用者。</li></ul><p>例子：</p><p>同步/异步：你干完了，怎么让我知道呢？</p><ul><li>同步：我只要不问，你就不告诉我</li><li>异步：你干完了，直接喊我过来就行</li></ul><p>以上的IO可以组合成4种组合方式：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞</p><h3 id="用户态和内核态">用户态和内核态</h3><p>两种不同的权限等级</p><h4 id="用户态">用户态</h4><p>只能执行系统规定的指令，当需要执行某些系统特权指令（系统调用）时，需要切换到内核态<img src="8.png" alt="系统调用位置" /></p><h4 id="内核态">内核态</h4><p>能够执行特权指令，如：IO，内存分配等对硬件操作的指令</p><h2 id="五种-io-模型">五种 I/O 模型</h2><p><img src="9.png" alt="五种 I/O 模型" /></p><h3 id="阻塞-io">阻塞 I/O</h3><p>优点：程序简单，线程挂起不会占用 CPU 资源<br />缺点：在高并发场景下，需要大量线程，那内存，线程切换开销是不可接受的<br />总之：不常用</p><h3 id="非阻塞-io">非阻塞 I/O</h3><p>优点：线程立刻返回，可以干别的活<br />缺点：不断轮询效率低，数据到达和轮询有时间差，所以响应延迟高<br />总之：不常用，最多使用非阻塞 I/O 的特性</p><h3 id="io-多路复用">I/O 多路复用</h3><p>Redis 作为一个单线程的数据库，使用的就是 I/O 多路复用</p><blockquote><p><strong>Redis 快的原因？</strong></p><ol type="1"><li>基于内存操作<br /></li><li>数据结构简单<br /></li><li>I/O 多路复用<br /></li><li>主线程为单线程，避免上下文切换</li></ol></blockquote><p>unix 的 select()，poll()，linux 的 epoll()系列都是同步非阻塞，windows 的 IOCP 是异步非阻塞</p><p><img src="3.png" alt="三种多路复用区别" /> 优点：一个线程复用多个Socket，避免了多线程创建，切换，销毁的开销</p><h4 id="select">select</h4><p><a href="https://man7.org/linux/man-pages/man2/select.2.html">API文档</a> <img src="4.png" alt="select" /></p><p>优点：解决了线程切换的问题<br />缺点：</p><ul><li>FD 最大默认为 1024</li><li>每次调用需要将 FD 从用户态拷贝到内核态</li><li>不知道哪个 FD 就绪，需要全部遍历</li><li>参数每次调用都要重置（因为 <code>readfds, writefds, exceptfds</code>要作为返回值）</li></ul><h4 id="poll">poll</h4><p><a href="https://man7.org/linux/man-pages/man2/poll.2.html">API文档</a> <img src="5.png" alt="poll" /></p><p>优点：解决了线程切换的问题<br />缺点：</p><ul><li><del>FD 最大默认为 1024</del></li><li>每次调用需要将 FD 从用户态拷贝到内核态</li><li>不知道哪个 FD 就绪，需要全部遍历</li><li><del>参数每次调用都要重置（因为<code>readfds, writefds, exceptfds</code> 要作为返回值）</del></li></ul><h4 id="epoll">epoll</h4><p><a href="https://man7.org/linux/man-pages/man7/epoll.7.html">API文档</a> <img src="6.png" alt="epoll-1" /> <img src="7.png"alt="epoll-2" /></p><p>LT：Level-Triggered，水平触发（默认），<code>epoll_wait</code>检测到事件后，如该事件没有处理完毕，后续 <code>epoll_wait</code>都会返回该事件，更安全<br />ET：Edge-Triggered，边缘触发，<code>epoll_wait</code>检测到事件后，只会在当次返回，不管该事件是否被处理完毕，更快</p><p>优点：解决了线程切换的问题<br />缺点：</p><ul><li><del>FD 最大默认为 1024</del></li><li><del>每次调用需要将 FD 从用户态拷贝到内核态</del></li><li><del>不知道哪个 FD 就绪，需要全部遍历</del></li><li><del>参数每次调用都要重置（因为<code>readfds, writefds, exceptfds</code> 要作为返回值）</del></li><li>跨平台不好，只支持 Linux</li><li>相比较 select，epoll 太重了，遇到监听连接数和事件较少的场景，select可能更优</li></ul><h3 id="异步-io">异步 I/O</h3><p>一般为非堵塞，除非刻意堵塞<br />应用进程执行 aio_read系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><h3 id="信号驱动-io">信号驱动 I/O</h3><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接口几乎是没用的，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么事情</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p><img src="10.png" alt="比较" /></p><h2 id="总结">总结</h2><p>本文介绍了 I/O 操作的基本概念，常见 I/O的五种模型，多路复用的三种方式</p><p><strong>最后提几个问题供读者检验成果：</strong></p><ol type="1"><li>阻塞和非阻塞有何区别，取决于什么？</li><li>同步和异步有何区别？</li><li>select，poll，epoll 有何区别？</li><li>Redis 为什么快？</li><li>同一个端口可以同时给 TCP 程序和 UDP 程序使用吗？</li><li>I/O 五个模型分别是什么？</li><li>socket 是什么，socket 地址是什么？</li></ol><h2 id="参考">参考</h2><p><a href="https://b23.tv/a9eq4SR">【小白也看得懂的 I/O多路复用解析（超详细案例）-哔哩哔哩】</a><br /><ahref="https://segmentfault.com/a/1190000039898780#:~:text=IO%20%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%8C%87%EF%BC%9A%E7%94%A8,%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%BC%82%E6%AD%A5IO%20%E6%A8%A1%E5%9E%8B%E3%80%82">浅聊Linux的五种IO模型</a><br /><ahref="https://xmmarlowe.github.io/2021/06/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/">用户态和内核态</a><br /><ahref="https://segmentfault.com/a/1190000041488709#:~:text=%E6%89%80%E8%B0%93%E7%9A%84I%2FO%E5%A4%9A,%E6%97%A0%E9%9C%80%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E3%80%82">深入理解redis——Redis快的原因和IO多路复用深度解析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 实现高性能内存池</title>
      <link href="/2022/08/25/c-shi-xian-gao-xing-neng-nei-cun-chi/"/>
      <url>/2022/08/25/c-shi-xian-gao-xing-neng-nei-cun-chi/</url>
      
        <content type="html"><![CDATA[<p>本篇文章将介绍内存池的原理以及实现<br />项目链接：<a class="theme-btn" href="https://github.com/cs-moushuai/MemoryPool" title="GitHub"><i class="fab fa-github fa-fw fa-lg"></i>GitHub</a></p><h2 id="什么是内存池">什么是内存池？</h2><p>内存池和线程池类似，一次申请大量的内存，程序需要内存就从池子里拿，析构就将内存放回池子里</p><h2 id="内存池的优缺点">内存池的优缺点</h2><h3 id="优点">优点</h3><ol type="1"><li>速度快，因为内存池绝大部分情况下是用户态、无锁、O(1)或O(logN)的时间复杂度，所以速度会比malloc/free要快很多。</li><li>避免内存碎片，频繁且不规律的malloc/free，尤其是大量小对象的时候，可能会导致内存释放后，空闲的内存块被已分配的内存块分割成无法合并的多块小“碎块”。此时突然申请一块大内存，虽然总的空闲内存大小是足够的，但我们却无法利用它们来完成内存分配。</li><li>增加内存的利用率，由于malloc在分配内存时，需要增加一些必要的簿记信息，也就是记录内存块信息的头部结构，因此每次内存分配都会导致一定程度的浪费。而内存池不同，可以做到按需分配。使用得当的话内存浪费会很小。</li></ol><h3 id="缺点">缺点</h3><p>使用内存池的缺点是会导致一定程度上的编程复杂度增加。不同方法实现的内存池有各自在使用上需要注意的地方，随随便便的用可能会引起意料之外的问题。</p><h2 id="什么时候使用内存池">什么时候使用内存池？</h2><p>当程序需要频繁在堆上申请和释放内存时</p><h2 id="内存池原理">内存池原理</h2><p>内存池的思想是，在真正使用内存之前，预先申请分配一定数量、大小预设的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存，当内存释放后就回归到内存块留作后续的复用，使得内存使用效率得到提升，一般也不会产生不可控制的内存碎片。</p><h3 id="结构">结构</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> Slot_ <span class="token punctuation">&#123;</span>    value_type element<span class="token punctuation">;</span> <span class="token comment">// 内存池内部元素类型</span>    Slot_<span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">// 指向下一个 block</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">char</span><span class="token operator">*</span>               data_pointer_<span class="token punctuation">;</span><span class="token keyword">typedef</span> Slot_               slot_type_<span class="token punctuation">;</span><span class="token keyword">typedef</span> Slot_<span class="token operator">*</span>              slot_pointer_<span class="token punctuation">;</span>slot_pointer_ currentBlock_<span class="token punctuation">;</span> <span class="token comment">// 指向当前块</span>slot_pointer_ currentSlot_<span class="token punctuation">;</span> <span class="token comment">// 指向当前块的 ele</span>slot_pointer_ lastSlot_<span class="token punctuation">;</span> <span class="token comment">// 指向当前块的最后一个 ele</span>slot_pointer_ freeSlots_<span class="token punctuation">;</span> <span class="token comment">// 释放的空间都存在空闲链表中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义了一个联合体，可以表现为元素，也可以表现为下一个 block 的指针</p><p><img src="memory_pool.001.jpeg" alt="内存池结构" /></p><p>其中 Next 指向下一个 Block（每个块默认大小为 4096B），Pad 为 Block减去 Next 后剩余大小对 ele 类型大小取模的结果，最后有若干个 ele 元素</p><h3 id="申请空间">申请空间</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">allocateBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 分配新 Block</span>    data_pointer_ newBlock <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>data_pointer_<span class="token operator">></span></span></span>                            <span class="token punctuation">(</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>BlockSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 头插法</span>    <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>newBlock<span class="token punctuation">)</span><span class="token operator">-></span>next <span class="token operator">=</span> currentBlock_<span class="token punctuation">;</span>    currentBlock_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>newBlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保留一个大小指向下一个区块的地址，计算 body 位置</span>    <span class="token comment">// 用 currentBlock_ 要类型转换</span>    data_pointer_ body <span class="token operator">=</span> newBlock <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>slot_pointer_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 计算 body 中填充位置</span>    size_type padding <span class="token operator">=</span> <span class="token function">padPointer</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>slot_type_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// currentSlot_ 指向（body+padding）头，lastSlot_ 指向最后一个位置地址 +1</span>    currentSlot_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>body <span class="token operator">+</span> padding<span class="token punctuation">)</span><span class="token punctuation">;</span>    lastSlot_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span>                <span class="token punctuation">(</span>newBlock <span class="token operator">+</span> BlockSize <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>slot_type_<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">typename</span> <span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span>pointer<span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_type n<span class="token punctuation">,</span> const_pointer hint<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>freeSlots_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pointer res <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>pointer<span class="token operator">></span></span></span><span class="token punctuation">(</span>freeSlots_<span class="token punctuation">)</span><span class="token punctuation">;</span>        freeSlots_ <span class="token operator">=</span> freeSlots_<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// todo 为什么优先使用 freeSlot_ 中的块，那当前的块不就浪费了吗</span>        <span class="token comment">// answer：freeSlots 存放的是 slot 不是 block，不影响当前块</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentSlot_ <span class="token operator">>=</span> lastSlot_<span class="token punctuation">)</span>            <span class="token function">allocateBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>pointer<span class="token operator">></span></span></span><span class="token punctuation">(</span>currentSlot_<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>申请空间先在空闲链表中找，若没有再再当前块中找，若用完了就去申请一个新块，分配新块中要注意填充空间，且分配空间用的是placement new，即只申请不构造而 new 是先申请后构造</p><p>placement new</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">data_pointer_ newBlock <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>data_pointer_<span class="token operator">></span></span></span>                            <span class="token punctuation">(</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>BlockSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在申请的空间上 construct</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span><span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">construct</span><span class="token punctuation">(</span>U<span class="token operator">*</span> p<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// todo 为什么类型是 U 不是 T</span>    <span class="token comment">// answer：U 是 value_type，本质也是 T</span>    <span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token function">U</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">></span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="释放空间">释放空间</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 释放单个元素</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span><span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>pointer p<span class="token punctuation">,</span> size_type n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-></span>next <span class="token operator">=</span> freeSlots_<span class="token punctuation">;</span>        freeSlots_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>slot_pointer_<span class="token operator">></span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 析构单个元素</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span><span class="token class-name">MemoryPool</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">destroy</span><span class="token punctuation">(</span>U<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        p<span class="token operator">-></span><span class="token operator">~</span><span class="token function">U</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 按块释放</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span>MemoryPool<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">MemoryPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 不要写 currentSlot_ 会将值当作地址</span>    slot_pointer_ curr <span class="token operator">=</span> currentBlock_<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        slot_pointer_ t <span class="token operator">=</span> curr<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">// 转化为 void* 避免调用 dtor</span>        <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curr <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>释放元素：先调用 <code>destroy</code> 后调用<code>deallocate</code><br />释放内存池：<code>~MemoryPool()</code></p><h3 id="移动">移动</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t BlockSize<span class="token operator">></span>MemoryPool<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token operator">&amp;</span>MemoryPool<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> BlockSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MemoryPool <span class="token operator">&amp;&amp;</span>rhs<span class="token punctuation">)</span><span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>currentBlock_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>currentBlock_<span class="token punctuation">)</span><span class="token punctuation">;</span>        currentSlot_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>currentSlot_<span class="token punctuation">;</span>        lastSlot_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>lastSlot_<span class="token punctuation">;</span>        freeSlots_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>freeSlots_<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：移动相关的函数都是 <code>noexcept</code>的，因为移动后原对象就可能损毁，不能进行第二次移动，另外非移动的且能保证一定不抛出异常的也可以用<code>noexcept</code> 来提高性能</p><h2 id="测试">测试</h2><p>链表栈的 <code>push</code> 和 <code>pop</code> 操作</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 入栈</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">StackAlloc</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">push</span><span class="token punctuation">(</span>T element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 为一个节点分配内存</span>    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> allocator_<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用节点的构造函数</span>    allocator_<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 入栈操作</span>    newNode<span class="token operator">-></span>data <span class="token operator">=</span> element<span class="token punctuation">;</span>    newNode<span class="token operator">-></span>prev <span class="token operator">=</span> head_<span class="token punctuation">;</span>    head_ <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 出栈</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Alloc</span><span class="token operator">></span>T <span class="token class-name">StackAlloc</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 出栈操作 返回出栈元素</span>    T result <span class="token operator">=</span> head_<span class="token operator">-></span>data<span class="token punctuation">;</span>    Node<span class="token operator">*</span> tmp <span class="token operator">=</span> head_<span class="token operator">-></span>prev<span class="token punctuation">;</span>    allocator_<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span>head_<span class="token punctuation">)</span><span class="token punctuation">;</span>    allocator_<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>head_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head_ <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ELEMS</span> <span class="token expression"><span class="token number">10000000</span></span></span><span class="token comment">// 重复次数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">REPS</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    clock_t start<span class="token punctuation">;</span>    <span class="token comment">// 使用 STL 默认分配器</span>    StackAlloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> stackDefault<span class="token punctuation">;</span>    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> REPS<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>stackDefault<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ELEMS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            stackDefault<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ELEMS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            stackDefault<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Default Allocator Time: "</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" s\n\n"</span><span class="token punctuation">;</span>    <span class="token comment">// 使用内存池</span>    StackAlloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> MemoryPool<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> stackPool<span class="token punctuation">;</span>    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> REPS<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>stackPool<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ELEMS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            stackPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ELEMS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            stackPool<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MemoryPool Allocator Time: "</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" s\n\n"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过链表栈的频繁 <code>push</code> 和 <code>pop</code>操作来测试性能</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Default Allocator Time: 59.2128 sMemoryPool Allocator Time: 12.0348 s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="总结">总结</h2><p>通过这个项目收获了内存分配的相关知识，对于 C++的相关特性，如模板，面向对象，可变参数，性能测试都有涉猎<br />最后这个项目也可以用单例模式来实现，这样整个程序就只有一个实例了，可以进一步调高性能，留给读者思考</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归 vs 迭代</title>
      <link href="/2022/08/24/di-gui-vs-die-dai/"/>
      <url>/2022/08/24/di-gui-vs-die-dai/</url>
      
        <content type="html"><![CDATA[<p>首先提出两个问题</p><ul><li>所有递归都可以改写成循环吗？</li><li>改写后会有什么好处？</li></ul><p>接下来我们仔细分析下具体的区别</p><h2 id="递归转换为迭代的方法">递归转换为迭代的方法</h2><p>对于递归而言有两种转换方式</p><h3 id="一直接转换法">一、直接转换法</h3><p><strong>方法</strong>：使用变量保存中间结果</p><p>计算阶乘：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>　　<span class="token keyword">else</span> <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>　　<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>　      res <span class="token operator">*=</span> i<span class="token punctuation">;</span>　　<span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，时间复杂度依旧为 <spanclass="math inline">\(\mathcal{O}(n)\)</span>，但空间复杂度已经从 <spanclass="math inline">\(\mathcal{O}(n) \to \mathcal{O}(1)\)</span>了，因为原本需要调用 <code>fact(...)</code> <spanclass="math inline">\(n\)</span> 次，但现在只需要 <spanclass="math inline">\(1\)</span> 次了</p><h3 id="二间接转换法">二、间接转换法</h3><p><strong>方法</strong>：使用栈保存中间结果</p><p>树的先序遍历：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">travel</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        TreeNode <span class="token operator">*</span>p<span class="token operator">=</span>root<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>p<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但此处的时间和空间复杂度却都没有变化，因为用栈来保存结果，本质就是在模拟函数调用的过程，并没有什么好处，但编写代码的难度却大大提高</p><p>所以，回答下开头的问题</p><h2 id="所有递归都可以改写成循环吗">所有递归都可以改写成循环吗？</h2><p>是的，所有递归都使用直接或间接的方式转换</p><h2 id="改写后会有什么好处">改写后会有什么好处？</h2><p>使用直接转换可以避免空间上的开销，使用间接转换本质在模拟函数调用没有意义</p><h2 id="总结">总结</h2><p>虽然递归有着很大的空间开销，但很多时候我们是很难用迭代写出我们想要的程序，而且空间上的开销也不是很重要，相比较迭代的自底向上，递归的自顶向下往往更符合人类的逻辑，很多时候做动态规划的题目没有思路的时候，都可以考虑用自顶向下的记忆化搜索来完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锂电池保养手册</title>
      <link href="/2022/08/23/li-dian-chi-bao-yang-shou-ce/"/>
      <url>/2022/08/23/li-dian-chi-bao-yang-shou-ce/</url>
      
        <content type="html"><![CDATA[<p>为什么有的人电池用了半年还有 <strong>100%</strong>，而有的人就剩下<strong>90%</strong> 了呢？</p><h2 id="原则">原则</h2><p>电池充电可以比喻成人吃饭，尽量少吃多餐</p><h2 id="现代锂电池充电规则">现代锂电池充电规则</h2><p><img src="1.jpeg" alt="放电流程" /></p><h2 id="注意点">注意点</h2><ol type="1"><li>避免在 <strong>20%</strong> 以下使用，尤其是 <strong>5%</strong>以下</li><li>电量保存在 <strong>25%-75%</strong></li><li>避免高温低温时使用，建议在 <strong>16-22度</strong> 间最好</li><li>高温时避免边冲边玩，快充也会提高温度，锂电池高温掉容量</li><li>长时间不用的电池要定时充电到 <strong>50%</strong>（每个6月）无电导致电池可能再也无法充电，满电可能导致容量下降</li><li>一个月进行一次充电循环，方法是将电池电量用到 <strong>15%</strong>左右，然后充满，就可以完成一次循环了</li></ol><blockquote><p>ps:一般设备，如macbook知道你经常充电就会将battery维持在80%以维持电压</p></blockquote><h2 id="电量对性能的影响">电量对性能的影响</h2><p>电量降低也会影响性能，而对于那些电池容量已经低于 <strong>80%</strong>的iPhone来说，影响体验的话，还是尽早换块新电池吧。</p><p>毕竟，在需要更极端的性能管理的情况下，体验上可能会受到影响，用苹果的话来说：</p><ul><li>应用启动时间变长</li><li>滚动时帧速率降低</li><li>背光灯变暗（可在“控制中心”手动调整）</li><li>扬声器音量降低幅度高达 -3dB</li><li>部分应用的帧速率逐渐降低</li><li>在最极端的情况下，相机闪光灯会被停用（会显示在相机用户界面上）</li><li>在后台刷新的应用在启动时可能需要重新载入</li></ul><h2 id="faq">FAQ</h2><h3 id="电池维持在-25-到-75-对电池好有这个说法吗">电池维持在 25 到 75对电池好，有这个说法吗？</h3><p>对的，因为高压低压对电池都不好</p><h3 id="电池会过冲吗">电池会过冲吗？</h3><p>不会，终端产品的锂电池都是双重保护的，适配器一个保护板，电池有一个保护板，超过保护板的最低电压它就停止放电了，充电同原理。基本不会存在过冲过放的问，但高压对电池不好<img src="2.png" alt="充电流程" /></p><h2 id="总结">总结</h2><p>电池是消耗品，换一个也就几百，必要的时候该怎么用就怎么用，如果真的想保护好电池，最简单的保障电量<strong>25%-75%</strong>，如果是 iphone的话，开启手机的优化充电模式，这样在你睡觉的时候大部分时间电量会保持在<strong>75%</strong>，且不要在手机温度过高的时候充电就够了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数码 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
